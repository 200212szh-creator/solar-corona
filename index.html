<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SOLAR CORONA | SIGNATURE RESTORED</title>
    <style>
        /* 1. Âü∫Á°ÄÁéØÂ¢É */
        body { 
            margin: 0; overflow: hidden; background: #000000; 
            font-family: 'Helvetica Neue', 'Arial', sans-serif; user-select: none; 
            cursor: default;
        }
        body.hide-cursor { cursor: none; }

        /* ÈÄöÁî®ÁéªÁíÉÊÄÅ */
        .glass-panel {
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 30px 80px rgba(0,0,0,0.95);
            border-radius: 12px;
        }

        /* 2. ÂÖ•Âè£Â±Ç */
        #entry-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1.5s cubic-bezier(0.6, 0, 0.2, 1);
        }

        .title-group { text-align: center; margin-bottom: 90px; position: relative; z-index: 2; }
        .main-title {
            color: #fff; font-size: 36px; letter-spacing: 18px; font-weight: 200;
            text-shadow: 0 0 40px rgba(255,255,255,0.3); margin-bottom: 20px;
            text-transform: uppercase; position: relative; display: inline-block;
        }
        .sub-title {
            color: rgba(255,255,255,0.4); font-size: 10px; letter-spacing: 8px; 
            font-family: 'Times New Roman', serif; text-transform: uppercase;
            border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;
        }
        .hint-text {
            margin-top: 30px; color: #666; font-size: 9px; letter-spacing: 2px;
            opacity: 0; transition: opacity 1s; font-weight: 400;
        }

        /* 3. ÂèåÂêØÂä®ÊåâÈíÆÁªÑ */
        .btn-group { display: flex; gap: 80px; z-index: 10; margin-top: 20px; }
        
        .halo-btn {
            width: 120px; height: 120px; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .halo-btn:hover { transform: scale(1.1); }
        .halo-btn:active { transform: scale(0.95); }

        .btn-ring {
            position: absolute; width: 100%; height: 100%; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.08);
            border-top: 1px solid rgba(255,255,255,0.6);
            animation: spin 8s linear infinite;
            transition: all 0.5s;
        }
        .btn-icon { 
            font-size: 26px; margin-bottom: 10px; color: rgba(255,255,255,0.9); 
            text-shadow: 0 0 20px rgba(255,255,255,0.3); transition: 0.4s; 
        }
        .btn-label { 
            color: rgba(255,255,255,0.5); font-size: 9px; letter-spacing: 3px; 
            transition: 0.4s; font-weight: 600; 
        }
        
        .halo-btn:hover .btn-ring { border-color: rgba(255,255,255,0.9); border-top-color: #fff; animation-duration: 1.5s; box-shadow: 0 0 40px rgba(255,255,255,0.2); }
        .halo-btn:hover .btn-label { color: #fff; letter-spacing: 5px; text-shadow: 0 0 15px #fff; }
        .halo-btn:hover .btn-icon { transform: scale(1.2); text-shadow: 0 0 40px #fff; color: #fff; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* 4. Â∫ïÈÉ®‰∏ìÂ±ûÁΩ≤Âêç (FIXED: È´ò‰ºòÂÖàÁ∫ßÔºåÁõ¥Êé•ÊéßÂà∂ opacity) */
        #signature {
            position: absolute; bottom: 35px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.25); font-size: 9px; letter-spacing: 6px;
            pointer-events: none; opacity: 0; transition: opacity 2s; font-weight: 300;
            text-shadow: 0 0 10px rgba(0,0,0,0.8); z-index: 4000; /* Á°Æ‰øùÂú®ÊúÄÈ°∂Â±Ç */
            font-family: 'Times New Roman', serif; white-space: nowrap;
            border-top: 1px solid rgba(255,255,255,0.05); padding-top: 15px;
        }
        
        /* 5. Ê®°ÂºèËèúÂçï */
        #mode-selector {
            position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; z-index: 20; padding: 10px 24px;
            opacity: 0; transition: opacity 1s;
            background: rgba(15, 15, 20, 0.6); backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 100px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); pointer-events: none;
        }
        #mode-selector.visible { opacity: 1; pointer-events: auto; }

        .mode-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.4);
            font-size: 10px; letter-spacing: 2px; cursor: pointer;
            transition: all 0.4s ease; font-weight: 500; padding: 8px 16px;
            text-transform: uppercase; position: relative; border-radius: 20px;
        }
        .mode-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .mode-btn.active { color: #fff; text-shadow: 0 0 15px rgba(255,255,255,0.5); background: rgba(255,255,255,0.15); }

        /* 6. È°∂ÈÉ®ÊéßÂà∂Âå∫ */
        .top-controls {
            position: absolute; right: 40px; top: 40px; z-index: 3000;
            display: flex; gap: 20px; align-items: center; 
            opacity: 0; transition: opacity 1s; pointer-events: none;
        }
        .top-controls.visible { opacity: 1; pointer-events: auto; }

        .ctrl-btn {
            width: 42px; height: 42px; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.3); backdrop-filter: blur(10px);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.4s; color: rgba(255,255,255,0.5);
            pointer-events: auto; position: relative;
        }
        .ctrl-btn:hover {
            border-color: rgba(255,255,255,0.8); color: #fff; 
            box-shadow: 0 0 25px rgba(255,255,255,0.2);
        }

        #color-indicator {
            width: 14px; height: 14px; border-radius: 50%;
            background-color: #ffffff; box-shadow: 0 0 15px rgba(255,255,255,0.6);
            transition: 0.3s; pointer-events: none;
        }

        /* 7. HUD Ë∞ÉËâ≤Áõò (‰øÆÂ§çÂÆö‰Ωç) */
        #hud-color-picker {
            position: absolute; top: 60px; right: 0px;
            width: 240px; height: 0px; overflow: hidden; border-radius: 12px;
            background: rgba(10, 10, 12, 0.95); backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: height 0.6s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.3s;
            opacity: 0; pointer-events: none; box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            z-index: 3001; /* Á°Æ‰øùÂú®Ë∞ÉËâ≤ÁõòÈ°∂Â±Ç */
        }
        #hud-color-picker.active { height: 290px; opacity: 1; pointer-events: auto; }
        
        .picker-content {
            padding: 25px; height: 100%; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center;
            background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .corner { position: absolute; width: 8px; height: 8px; border: 1px solid rgba(255,255,255,0.4); pointer-events: none; }
        .tl { top: 8px; left: 8px; border-right: none; border-bottom: none; }
        .tr { top: 8px; right: 8px; border-left: none; border-bottom: none; }
        .bl { bottom: 8px; left: 8px; border-right: none; border-top: none; }
        .br { bottom: 8px; right: 8px; border-left: none; border-top: none; }

        #color-wheel-container {
            width: 160px; height: 160px; position: relative; margin-bottom: 20px;
            border-radius: 50%; cursor: crosshair;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.08);
        }
        #color-canvas { width: 100%; height: 100%; border-radius: 50%; display: block; }
        
        #picker-cursor {
            position: absolute; width: 12px; height: 12px; 
            border: 2px solid #fff; border-radius: 50%; 
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; box-shadow: 0 0 10px rgba(255,255,255,0.8);
            transition: none;
        }

        .picker-label { color: #666; font-size: 9px; letter-spacing: 4px; margin-bottom: 15px; font-weight: 700; }
        .hex-disp { color: #fff; font-family: monospace; font-size: 11px; letter-spacing: 2px; border-bottom: 1px solid #444; padding-bottom: 4px; }
        
        #color-input { display: none; }

        #btn-fullscreen { font-size: 14px; }
        #btn-fullscreen:hover { color: #fff; }

        .visible { opacity: 1 !important; pointer-events: auto !important; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="top-controls" id="top-bar">
        <div style="position: relative;">
            <div class="ctrl-btn" id="btn-color" onclick="togglePicker()" title="Spectral Tuner">
                <div id="color-indicator"></div>
                <input type="color" id="color-input" value="#ffffff">
            </div>
            
            <div id="hud-color-picker" class="glass-panel">
                <div class="corner tl"></div><div class="corner tr"></div>
                <div class="corner bl"></div><div class="corner br"></div>
                <div class="picker-content">
                    <div class="picker-label">SPECTRUM</div>
                    <div id="color-wheel-container">
                        <canvas id="color-canvas" width="300" height="300"></canvas>
                        <div id="picker-cursor"></div>
                    </div>
                    <div class="hex-disp" id="hex-val">#FFFFFF</div>
                </div>
            </div>
        </div>
        
        <button class="ctrl-btn" id="btn-fullscreen" onclick="toggleFullscreen()" title="Fullscreen">‚õ∂</button>
    </div>

    <div id="entry-layer">
        <div class="title-group">
            <div class="main-title">Solar Corona</div>
            <div class="sub-title">Sun Zhonghang ¬∑ Final Oath</div>
            <div class="hint-text" id="sys-hint">SYSTEM MODE: PLEASE CHECK "SHARE AUDIO"</div>
        </div>
        
        <div class="btn-group">
            <div class="halo-btn" onclick="startSequence('sys')">
                <div class="btn-ring"></div>
                <div class="btn-icon">üñ•Ô∏è</div>
                <div class="btn-label">SYSTEM</div>
            </div>
            <div class="halo-btn" onclick="startSequence('mic')">
                <div class="btn-ring"></div>
                <div class="btn-icon">üé§</div>
                <div class="btn-label">MIC / MIX</div>
            </div>
        </div>
    </div>

    <div id="mode-selector">
        <button class="mode-btn active" onclick="setMode('TIDES')">TIDES</button>
        <button class="mode-btn" onclick="setMode('HORIZON')">HORIZON</button>
        <button class="mode-btn" onclick="setMode('RIPPLE')">RIPPLE</button>
        <button class="mode-btn" onclick="setMode('WARP')">WARP</button>
    </div>

    <div id="signature">SUN ZHONGHANG</div>

    <script>
        const CONFIG = {
            gridX: 240, gridZ: 120, spacing: 1.3,
            colorDeep: new THREE.Color("#000000"), 
            colorPeak: new THREE.Color("#ffffff")
        };

        let audioCtx, analyser, dataArray;
        let wallpaperAudioData = null; 
        let isSimulating = false, isRunning = false, isPaused = false;
        let time = 0;
        let currentMode = 'TIDES'; 
        
        let volumeHistory = []; 
        let autoGain = 1.0;
        let sBass = 0, sMid = 0, sHigh = 0;

        const currentY = new Float32Array(CONFIG.gridX * CONFIG.gridZ); 
        let mouseX = 0, mouseY = 0;
        let curMouseX = 0, curMouseY = 0;

        // --- HUD Picker Logic (Final Fixed) ---
        const pickerCanvas = document.getElementById('color-canvas');
        const pCtx = pickerCanvas.getContext('2d');
        const pContainer = document.getElementById('color-wheel-container');
        const pCursor = document.getElementById('picker-cursor');
        const pickerPanel = document.getElementById('hud-color-picker');
        let isPickerOpen = false;

        function drawColorWheel() {
            const size = 160; const scale = 2;
            pickerCanvas.style.width = size + 'px'; pickerCanvas.style.height = size + 'px';
            const radius = size * scale / 2;
            const image = pCtx.createImageData(2 * radius, 2 * radius);
            const data = image.data;
            for (let x = -radius; x < radius; x++) {
                for (let y = -radius; y < radius; y++) {
                    const [r, phi] = xy2polar(x, y);
                    if (r > radius) continue;
                    const deg = (phi * 180) / Math.PI + 180; 
                    const color = new THREE.Color().setHSL(deg / 360, 1.0, 0.6);
                    const index = ((x + radius) + (y + radius) * (2 * radius)) * 4;
                    data[index] = color.r * 255; data[index+1] = color.g * 255; data[index+2] = color.b * 255; data[index+3] = 255;
                }
            }
            pCtx.putImageData(image, 0, 0);
        }
        function xy2polar(x, y) { return [Math.sqrt(x*x + y*y), Math.atan2(y, x)]; }
        drawColorWheel();

        function handleColorPick(e) {
            const rect = pContainer.getBoundingClientRect();
            const w = rect.width; const h = rect.height;
            const x = e.clientX - rect.left; const y = e.clientY - rect.top;
            const nx = (x / w) * 2 - 1; const ny = (y / h) * 2 - 1;
            const dist = Math.sqrt(nx*nx + ny*ny);
            let finalX = nx, finalY = ny;
            if (dist > 1) { finalX = nx / dist; finalY = ny / dist; }
            pCursor.style.left = `${(finalX + 1) * 50}%`;
            pCursor.style.top = `${(finalY + 1) * 50}%`;
            const angle = Math.atan2(finalY, finalX) + Math.PI;
            const hue = angle / (Math.PI * 2);
            const sat = Math.min(1, Math.sqrt(finalX*finalX + finalY*finalY));
            const color = new THREE.Color().setHSL(hue, 1.0, 0.5 + (1-sat)*0.5);
            updateSystemColor(color);
        }

        let isDraggingColor = false;
        pContainer.addEventListener('mousedown', (e) => { isDraggingColor = true; handleColorPick(e); });
        window.addEventListener('mouseup', () => isDraggingColor = false);
        window.addEventListener('mousemove', (e) => { if(isDraggingColor) handleColorPick(e); });
        pContainer.addEventListener('click', handleColorPick);

        function togglePicker() {
            isPickerOpen = !isPickerOpen;
            if(isPickerOpen) pickerPanel.classList.add('active');
            else pickerPanel.classList.remove('active');
        }
        document.addEventListener('click', (e) => {
            if (!document.getElementById('btn-color').contains(e.target) && !pickerPanel.contains(e.target)) {
                isPickerOpen = false; pickerPanel.classList.remove('active');
            }
        });

        function updateSystemColor(color) {
            const hexStr = '#' + color.getHexString().toUpperCase();
            document.getElementById('color-indicator').style.backgroundColor = hexStr;
            document.getElementById('color-indicator').style.boxShadow = `0 0 15px ${hexStr}`;
            document.getElementById('hex-val').innerText = hexStr;
            document.getElementById('btn-color').style.borderColor = hexStr;
            
            CONFIG.colorPeak.copy(color);
            const hsl = {}; color.getHSL(hsl);
            CONFIG.colorDeep.setHSL(hsl.h, hsl.s * 0.6, 0.02);
        }

        // --- ‰∫§‰∫í ---
        document.addEventListener('keydown', (e) => {
            if (!isRunning) return;
            switch(e.key) {
                case '1': setMode('TIDES'); break;
                case '2': setMode('HORIZON'); break;
                case '3': setMode('RIPPLE'); break;
                case '4': setMode('WARP'); break;
                case ' ': isPaused = !isPaused; break;
                case 'f': toggleFullscreen(); break; 
            }
        });

        let idleTimer;
        const resetIdleTimer = () => {
            document.body.classList.add('show-cursor');
            clearTimeout(idleTimer);
            if(isRunning) idleTimer = setTimeout(() => { if(!isPickerOpen) document.body.classList.remove('show-cursor'); }, 2000);
        };
        document.addEventListener('mousemove', resetIdleTimer);

        window.setMode = (mode) => {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText === mode) btn.classList.add('active');
            });
        };

        window.toggleFullscreen = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => {});
            else if (document.exitFullscreen) document.exitFullscreen();
        };

        // Wallpaper Engine Support
        window.wallpaperPropertyListener = { applyUserProperties: function(properties) {} };
        window.wallpaperRegisterAudioListener && window.wallpaperRegisterAudioListener((audioArray) => {
            wallpaperAudioData = audioArray;
            if(!isRunning) autoStartWallpaperMode();
        });

        function autoStartWallpaperMode() {
            const layer = document.getElementById('entry-layer');
            layer.style.display = 'none';
            document.getElementById('signature').classList.add('visible');
            document.getElementById('mode-selector').classList.add('visible');
            document.getElementById('top-bar').classList.add('visible');
            document.getElementById('btn-fullscreen').style.display = 'none';
            isRunning = true;
            animate();
        }

        async function startSequence(type) {
            const btns = document.querySelectorAll('.halo-btn');
            btns.forEach(b => { b.style.transform = 'scale(0.9)'; b.style.opacity = '0'; b.style.pointerEvents = 'none'; });
            
            if(type === 'sys') document.getElementById('sys-hint').style.opacity = 1;

            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                let stream;
                if (type === 'sys') {
                    stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: { echoCancellation: false } });
                    stream.getVideoTracks().forEach(t => t.stop());
                    if(stream.getAudioTracks().length === 0) throw new Error("No audio");
                } else {
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }

                audioCtx = new AudioContext();
                const src = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; 
                analyser.smoothingTimeConstant = 0.82; // ÊúÄÁªàÁ®≥ÂÆöÁ≥ªÊï∞
                src.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) { 
                console.log("Audio failed, SIM mode");
                isSimulating = true; 
            }

            const layer = document.getElementById('entry-layer');
            layer.style.opacity = 0;
            setTimeout(() => {
                layer.style.display = 'none';
                document.getElementById('signature').classList.add('visible');
                document.getElementById('mode-selector').classList.add('visible');
                document.getElementById('top-bar').classList.add('visible');
                resetIdleTimer();
            }, 1000);
            isRunning = true;
        }

        // --- 2. Âú∫ÊôØ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012); 
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 80);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, alpha: false, powerPreference: "high-performance", preserveDrawingBuffer: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const fadeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.15 });
        const fadePlane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), fadeMaterial);
        fadePlane.position.z = -1; 
        const fadeScene = new THREE.Scene();
        fadeScene.add(fadePlane);

        const pCount = CONFIG.gridX * CONFIG.gridZ;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(pCount * 3);
        const colors = new Float32Array(pCount * 3);
        const sizes = new Float32Array(pCount);
        const baseCoords = new Float32Array(pCount * 2);

        let i = 0;
        const offsetX = (CONFIG.gridX * CONFIG.spacing) / 2;
        const offsetZ = (CONFIG.gridZ * CONFIG.spacing) / 2;

        for(let z=0; z<CONFIG.gridZ; z++) {
            for(let x=0; x<CONFIG.gridX; x++) {
                const px = x * CONFIG.spacing - offsetX;
                const pz = z * CONFIG.spacing - offsetZ - 20;
                positions[i*3] = px; positions[i*3+1] = 0; positions[i*3+2] = pz;
                baseCoords[i*2] = px; baseCoords[i*2+1] = pz;
                currentY[i] = 0;
                colors[i*3]=0; colors[i*3+1]=0; colors[i*3+2]=0;
                sizes[i] = 1.0;
                i++;
            }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=128;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(64,64,0,64,64,64);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.3, 'rgba(255,255,255,0.8)');
        g.addColorStop(0.5, 'rgba(255,255,255,0.15)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
        const tex = new THREE.Texture(canvas); tex.needsUpdate=true;

        const material = new THREE.PointsMaterial({
            size: 1.3, map: tex, vertexColors: true, 
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0
        });
        const mesh = new THREE.Points(geometry, material);
        scene.add(mesh);

        function animate() {
            requestAnimationFrame(animate);
            if(isPaused) return;
            time += 0.008;

            fadeMaterial.color.copy(CONFIG.colorDeep);
            renderer.render(fadeScene, camera);

            let bass = 0, mid = 0, high = 0;
            let currentVolume = 0;

            if (wallpaperAudioData) {
                let bSum=0, mSum=0, hSum=0;
                for(let k=0; k<4; k++) bSum += wallpaperAudioData[k];
                for(let k=10; k<25; k++) mSum += wallpaperAudioData[k];
                for(let k=40; k<64; k++) hSum += wallpaperAudioData[k];
                bass = (bSum/4)*2.0; mid = (mSum/15)*1.5; high = (hSum/24)*2.5;
                currentVolume = bass + mid + high;
            } else if (isRunning && !isSimulating && analyser) {
                analyser.getByteFrequencyData(dataArray);
                for(let k=0; k<15; k++) bass += dataArray[k]; bass /= 3825; 
                for(let k=20; k<120; k++) mid += dataArray[k]; mid /= 25500;
                for(let k=200; k<500; k++) high += dataArray[k]; high /= 76500;
                currentVolume = bass + mid + high;
            } else {
                bass = (Math.sin(time*2)+1)*0.2; mid = (Math.cos(time*1.5)+1)*0.15; high = (Math.sin(time*4)+1)*0.1;
                currentVolume = 0.5;
            }

            if (!isSimulating && isRunning) {
                volumeHistory.push(currentVolume);
                if (volumeHistory.length > 60) volumeHistory.shift();
                let avgVol = volumeHistory.reduce((a, b) => a + b, 0) / volumeHistory.length;
                let targetGain = 0.3 / (avgVol + 0.01);
                targetGain = Math.min(Math.max(targetGain, 1.0), 5.0);
                autoGain += (targetGain - autoGain) * 0.05;
            } else { autoGain = 1.0; }

            bass *= autoGain * 1.5; mid *= autoGain * 1.3; high *= autoGain * 1.8;

            // [Ê†∏ÂøÉ] Èü≥È¢ëÊÉØÊÄßÂπ≥Êªë
            if (bass > sBass) sBass = bass; else sBass += (bass - sBass) * 0.12;
            if (mid > sMid) sMid = mid; else sMid += (mid - sMid) * 0.1;
            if (high > sHigh) sHigh = high; else sHigh += (high - sHigh) * 0.2;

            let pBass = sBass; let pMid = sMid; let pHigh = sHigh;

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            const siz = geometry.attributes.size.array;
            const tempColor = new THREE.Color();

            let targetCamY = 15;
            let targetCamZOffset = 0;
            curMouseX += (mouseX - curMouseX) * 0.05;
            curMouseY += (mouseY - curMouseY) * 0.05;

            for(let i=0; i<pCount; i++) {
                const ix = i*3;
                const bx = baseCoords[i*2]; const bz = baseCoords[i*2+1];
                let targetY = 0; let targetX = bx; let targetZ = bz;

                if (currentMode === 'TIDES') {
                    targetCamY = 15;
                    const wave = Math.sin(bx * 0.05 + time) * Math.cos(bz * 0.05 + time * 0.5) * 3;
                    const xNorm = (bx + offsetX) / (CONFIG.gridX * CONFIG.spacing);
                    const bassFactor = Math.max(0, 1 - xNorm * 1.5);
                    const midFactor = Math.max(0, (xNorm - 0.3) * 1.5);
                    const audioForce = (pBass * bassFactor * 35) + (pMid * midFactor * 25);
                    targetY = wave + Math.sin(bz * 0.2 - time * 3) * audioForce;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.25; 
                    pos[ix] += (targetX - pos[ix]) * 0.1; pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'HORIZON') {
                    targetCamY = 8;
                    const distX = Math.abs(bx);
                    const tunnel = Math.pow(distX / 30, 2.5) * (1.5 + pBass * 0.5); 
                    const flow = Math.sin(bz * 0.1 + time * 8); 
                    targetY = tunnel + flow * (pMid * 20);
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.25;
                    pos[ix] += (targetX - pos[ix]) * 0.1; pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'RIPPLE') {
                    targetCamY = 40; targetCamZOffset = 20;
                    const dist = Math.sqrt(bx*bx + bz*bz);
                    const ripple = Math.sin(dist * 0.12 - time * 3);
                    const decay = Math.max(0, 1 - dist / 120);
                    targetY = ripple * decay * (3 + pBass * 30 + pMid * 15);
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.3;
                    pos[ix] += (targetX - pos[ix]) * 0.1; pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'WARP') {
                    targetCamY = 0; 
                    const angle = (bx / offsetX) * Math.PI; const radius = 30 + pBass * 25; 
                    const flowZ = (bz + time * 120) % 100 - 50; 
                    targetX = Math.cos(angle) * radius; targetY = Math.sin(angle) * radius; targetZ = flowZ; 
                    if (pHigh > 0.1) {
                        const spike = Math.random() * pHigh * 6;
                        targetX += Math.cos(angle) * spike; targetY += Math.sin(angle) * spike;
                    }
                    pos[ix] += (targetX - pos[ix]) * 0.15;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.15;
                    if (Math.abs(pos[ix+2] - targetZ) > 50) pos[ix+2] = targetZ;
                    else pos[ix+2] += (targetZ - pos[ix+2]) * 0.3;
                }

                let intensity = 0;
                if (currentMode === 'WARP') intensity = 1 - (Math.abs(pos[ix+2]) / 60);
                else if (currentMode === 'RIPPLE') intensity = (pos[ix+1] + 5) / 25;
                else intensity = (pos[ix+1] + 10) / 30;
                
                intensity = Math.max(0, Math.min(1, intensity));
                intensity = Math.pow(intensity, 2.2);

                tempColor.copy(CONFIG.colorDeep);
                tempColor.lerp(CONFIG.colorPeak, intensity);

                // [‰øÆÂ§ç] È¢úËâ≤Á∫ØÂáÄÔºå‰ªÖÂ¢û‰∫ÆÔºå‰∏çÂÅèËâ≤
                if(pHigh > 0.2 && intensity > 0.4) {
                    tempColor.r += pHigh * 0.5; tempColor.g += pHigh * 0.5; tempColor.b += pHigh * 0.5;
                }

                col[ix] = tempColor.r; col[ix+1] = tempColor.g; col[ix+2] = tempColor.b;
                siz[i] = 0.8 + intensity * 4.0;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;

            const pX = curMouseX * 5; const pY = -curMouseY * 5;
            camera.position.x += (pX - camera.position.x) * 0.05;
            camera.position.y += ((targetCamY + pY) - camera.position.y) * 0.05;
            camera.position.z = 80 + targetCamZOffset + Math.sin(time * 0.08) * 8;
            camera.lookAt(0, -2, 0);

            renderer.clearDepth();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
