<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SOLAR CORONA | HUD FIX</title>
    <style>
        /* 1. 基础环境 */
        body { 
            margin: 0; overflow: hidden; background: #000000; 
            font-family: 'Helvetica Neue', 'Arial', sans-serif; user-select: none; 
            cursor: default;
        }
        body.hide-cursor { cursor: none; }

        /* 通用玻璃态 */
        .glass-panel {
            background: rgba(15, 15, 20, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 20px 60px rgba(0,0,0,0.9);
        }

        /* 2. 入口层 */
        #entry-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1.5s cubic-bezier(0.6, 0, 0.2, 1);
        }

        .title-group { text-align: center; margin-bottom: 100px; position: relative; z-index: 2; }
        .main-title {
            color: #fff; font-size: 36px; letter-spacing: 18px; font-weight: 200;
            text-shadow: 0 0 40px rgba(255,255,255,0.3); margin-bottom: 20px;
            text-transform: uppercase; position: relative; display: inline-block;
        }
        .main-title::after {
            content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 1px; background: rgba(255,255,255,0.3);
        }
        .sub-title {
            color: rgba(255,255,255,0.35); font-size: 10px; letter-spacing: 8px; 
            font-family: 'Times New Roman', serif; text-transform: uppercase;
        }

        /* 3. 核心按钮 */
        .halo-container {
            position: relative; width: 160px; height: 160px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .halo-container:hover { transform: scale(1.05); }

        .ring-outer {
            position: absolute; width: 100%; height: 100%; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.05);
            border-top: 1px solid rgba(255,255,255,0.5);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            animation: spin 8s linear infinite; box-shadow: 0 0 30px rgba(255,255,255,0.02);
        }
        .ring-mid {
            position: absolute; width: 75%; height: 75%; border-radius: 50%;
            border: 1px dashed rgba(255,255,255,0.2); animation: spin-rev 12s linear infinite;
        }
        .ring-inner {
            position: absolute; width: 40%; height: 40%; border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border: 1px solid rgba(255,255,255,0.3); box-shadow: 0 0 20px rgba(255,255,255,0.1);
            transition: 0.4s;
        }
        .halo-text {
            position: relative; color: rgba(255,255,255,0.5); font-size: 9px; letter-spacing: 4px;
            z-index: 10; transition: 0.4s; font-weight: 400;
        }
        .halo-container:hover .ring-outer { animation-duration: 2s; border-color: rgba(255,255,255,0.8); box-shadow: 0 0 50px rgba(255,255,255,0.2); }
        .halo-container:hover .ring-inner { width: 45%; height: 45%; background: rgba(255,255,255,0.9); box-shadow: 0 0 60px rgba(255,255,255,0.8); }
        .halo-container:hover .halo-text { color: #000; font-weight: 700; letter-spacing: 2px; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes spin-rev { 0% { transform: rotate(360deg); } 100% { transform: rotate(0deg); } }

        /* 4. 底部专属署名 */
        #signature {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.2); font-size: 9px; letter-spacing: 6px;
            pointer-events: none; opacity: 0; transition: opacity 2s; font-family: 'Times New Roman', serif;
            border-top: 1px solid rgba(255,255,255,0.05); padding-top: 10px;
        }
        
        /* 5. 模式菜单 */
        #mode-selector {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 20; padding: 8px 20px;
            opacity: 0; transition: opacity 2s 1s; border-radius: 50px;
        }
        .mode-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.4);
            font-size: 10px; letter-spacing: 2px; cursor: pointer;
            transition: all 0.4s ease; font-weight: 500; padding: 8px 16px;
            text-transform: uppercase; position: relative; border-radius: 20px;
        }
        .mode-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .mode-btn.active { color: #fff; text-shadow: 0 0 15px rgba(255,255,255,0.6); background: rgba(255,255,255,0.1); }

        /* 6. 顶部控制区 */
        .top-controls {
            position: absolute; top: 30px; right: 30px; z-index: 3000;
            display: flex; gap: 15px; align-items: center; 
            opacity: 0; transition: opacity 2s; pointer-events: none;
        }

        .ctrl-btn {
            width: 40px; height: 40px; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(0,0,0,0.2); backdrop-filter: blur(10px);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.3s; color: rgba(255,255,255,0.5);
            pointer-events: auto; position: relative;
        }
        .ctrl-btn:hover {
            border-color: rgba(255,255,255,0.8); box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        #btn-fullscreen { font-size: 14px; }
        #btn-fullscreen:hover { color: #fff; }

        /* 颜色指示点 */
        #color-indicator {
            width: 12px; height: 12px; border-radius: 50%;
            background-color: #ffffff; box-shadow: 0 0 10px rgba(255,255,255,0.8);
            transition: 0.3s; pointer-events: none;
        }

        /* 7. HUD 调色盘 (Fix) */
        #hud-color-picker {
            position: absolute; top: 55px; right: 0px;
            width: 220px; height: 0px; overflow: hidden; border-radius: 8px;
            transition: height 0.5s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.3s;
            opacity: 0; pointer-events: none;
        }
        #hud-color-picker.active { height: 270px; opacity: 1; pointer-events: auto; }
        
        .picker-content {
            padding: 20px; height: 100%; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center;
            background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .corner { position: absolute; width: 8px; height: 8px; border: 1px solid rgba(255,255,255,0.4); pointer-events: none; }
        .tl { top: 6px; left: 6px; border-right: none; border-bottom: none; }
        .tr { top: 6px; right: 6px; border-left: none; border-bottom: none; }
        .bl { bottom: 6px; left: 6px; border-right: none; border-top: none; }
        .br { bottom: 6px; right: 6px; border-left: none; border-top: none; }

        #color-wheel {
            width: 150px; height: 150px; border-radius: 50%; cursor: crosshair;
            box-shadow: 0 0 30px rgba(0,0,0,0.5); margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .picker-label { color: #666; font-size: 8px; letter-spacing: 3px; margin-bottom: 15px; font-weight: 700; }
        .hex-disp { color: #fff; font-family: monospace; font-size: 10px; letter-spacing: 2px; border-bottom: 1px solid #333; padding-bottom: 4px; }

        .visible { opacity: 1 !important; pointer-events: auto !important; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="top-controls" id="top-bar">
        <div style="position: relative;">
            <div class="ctrl-btn" id="btn-color" onclick="togglePicker()" title="Spectral Tuner">
                <div id="color-indicator"></div>
            </div>
            
            <div id="hud-color-picker" class="glass-panel">
                <div class="corner tl"></div><div class="corner tr"></div>
                <div class="corner bl"></div><div class="corner br"></div>
                <div class="picker-content">
                    <div class="picker-label">SPECTRUM</div>
                    <canvas id="color-wheel" width="300" height="300"></canvas>
                    <div class="hex-disp" id="hex-val">#FFFFFF</div>
                </div>
            </div>
        </div>
        
        <button class="ctrl-btn" id="btn-fullscreen" onclick="toggleFullscreen()" title="Fullscreen">⛶</button>
    </div>

    <div id="entry-layer">
        <div class="title-group">
            <div class="main-title">Solar Corona</div>
            <div class="sub-title">Sun Zhonghang · Complete</div>
        </div>
        
        <div class="halo-container" onclick="startSequence()">
            <div class="ring-outer"></div>
            <div class="ring-mid"></div>
            <div class="ring-inner"></div>
            <div class="halo-text">ENTER</div>
        </div>
    </div>

    <div id="mode-selector" class="glass-panel">
        <button class="mode-btn active" onclick="setMode('TIDES')">TIDES</button>
        <button class="mode-btn" onclick="setMode('HORIZON')">HORIZON</button>
        <button class="mode-btn" onclick="setMode('RIPPLE')">RIPPLE</button>
        <button class="mode-btn" onclick="setMode('WARP')">WARP</button>
    </div>

    <div id="signature">SUN ZHONGHANG</div>

    <script>
        // --- 0. 配置 ---
        const CONFIG = {
            gridX: 240, gridZ: 120, spacing: 1.3,
            colorDeep: new THREE.Color("#000000"), 
            colorPeak: new THREE.Color("#ffffff")
        };

        // --- 1. 状态 ---
        let audioCtx, analyser, dataArray;
        let wallpaperAudioData = null; 
        let isSimulating = false, isRunning = false, isPaused = false;
        let time = 0;
        let currentMode = 'TIDES'; 
        let volumeHistory = []; 
        let autoGain = 1.0;
        const currentY = new Float32Array(CONFIG.gridX * CONFIG.gridZ); 
        let mouseX = 0, mouseY = 0;
        let curMouseX = 0, curMouseY = 0;

        // --- 修复版 HUD Picker 逻辑 ---
        const pickerCanvas = document.getElementById('color-wheel');
        const pCtx = pickerCanvas.getContext('2d');
        const pickerPanel = document.getElementById('hud-color-picker');
        let isPickerOpen = false;

        function drawColorWheel() {
            // 确保 Canvas 内部分辨率匹配 CSS 尺寸 (Retina 2x)
            const size = 300; 
            const radius = size / 2;
            const image = pCtx.createImageData(size, size);
            const data = image.data;

            for (let x = -radius; x < radius; x++) {
                for (let y = -radius; y < radius; y++) {
                    const [r, phi] = xy2polar(x, y);
                    if (r > radius) continue;
                    const deg = (phi * 180) / Math.PI + 180; 
                    const color = new THREE.Color().setHSL(deg / 360, 1.0, 0.6);
                    const index = ((x + radius) + (y + radius) * size) * 4;
                    data[index] = color.r * 255; data[index+1] = color.g * 255; data[index+2] = color.b * 255; data[index+3] = 255;
                }
            }
            pCtx.putImageData(image, 0, 0);
        }
        function xy2polar(x, y) { return [Math.sqrt(x*x + y*y), Math.atan2(y, x)]; }
        drawColorWheel();

        function pickColor(e) {
            const rect = pickerCanvas.getBoundingClientRect();
            // 【修复】精确的坐标映射
            const scaleX = pickerCanvas.width / rect.width;
            const scaleY = pickerCanvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            const pixel = pCtx.getImageData(x, y, 1, 1).data;
            if(pixel[3] === 0) return; // 透明区域

            const hex = new THREE.Color(pixel[0]/255, pixel[1]/255, pixel[2]/255);
            updateSystemColor(hex);
        }

        let isDraggingColor = false;
        pickerCanvas.addEventListener('mousedown', () => isDraggingColor = true);
        document.addEventListener('mouseup', () => isDraggingColor = false);
        pickerCanvas.addEventListener('mousemove', (e) => { if(isDraggingColor) pickColor(e); });
        pickerCanvas.addEventListener('click', pickColor);

        function togglePicker() {
            isPickerOpen = !isPickerOpen;
            if(isPickerOpen) pickerPanel.classList.add('active');
            else pickerPanel.classList.remove('active');
        }
        // 点击外部关闭
        document.addEventListener('click', (e) => {
            if (!document.getElementById('btn-color').contains(e.target) && 
                !pickerPanel.contains(e.target)) {
                isPickerOpen = false; pickerPanel.classList.remove('active');
            }
        });

        function updateSystemColor(color) {
            const hexStr = '#' + color.getHexString().toUpperCase();
            document.getElementById('color-indicator').style.backgroundColor = hexStr;
            document.getElementById('color-indicator').style.boxShadow = `0 0 15px ${hexStr}`;
            document.getElementById('hex-val').innerText = hexStr;
            document.getElementById('btn-color').style.borderColor = hexStr;
            
            CONFIG.colorPeak.copy(color);
            const hsl = {}; color.getHSL(hsl);
            CONFIG.colorDeep.setHSL(hsl.h, hsl.s * 0.8, 0.02);
        }

        // --- 交互 ---
        document.addEventListener('keydown', (e) => {
            if (!isRunning) return;
            switch(e.key) {
                case '1': setMode('TIDES'); break;
                case '2': setMode('HORIZON'); break;
                case '3': setMode('RIPPLE'); break;
                case '4': setMode('WARP'); break;
                case ' ': isPaused = !isPaused; break;
                case 'f': toggleFullscreen(); break; 
            }
        });

        let idleTimer;
        const resetIdleTimer = () => {
            document.body.classList.add('show-cursor');
            clearTimeout(idleTimer);
            if(isRunning) idleTimer = setTimeout(() => { if(!isPickerOpen) document.body.classList.remove('show-cursor'); }, 2000);
        };
        document.addEventListener('mousemove', resetIdleTimer);

        window.setMode = (mode) => {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText === mode) btn.classList.add('active');
            });
        };

        window.toggleFullscreen = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => {});
            else if (document.exitFullscreen) document.exitFullscreen();
        };

        window.wallpaperPropertyListener = { applyUserProperties: function(properties) {} };
        window.wallpaperRegisterAudioListener && window.wallpaperRegisterAudioListener((audioArray) => {
            wallpaperAudioData = audioArray;
            if(!isRunning) autoStartWallpaperMode();
        });

        function autoStartWallpaperMode() {
            const layer = document.getElementById('entry-layer');
            if(layer.style.display !== 'none') {
                layer.style.display = 'none'; 
                document.getElementById('signature').classList.add('visible');
                document.getElementById('mode-selector').classList.add('visible');
                document.getElementById('top-bar').classList.add('visible');
                document.getElementById('btn-fullscreen').style.display = 'none'; 
                isRunning = true;
                resetIdleTimer();
                animate(); 
            }
        }

        async function startSequence() {
            const btn = document.querySelector('.halo-container');
            btn.style.transform = 'scale(0.9)'; btn.style.opacity = '0'; btn.style.pointerEvents = 'none';
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new AudioContext();
                const src = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; 
                analyser.smoothingTimeConstant = 0.75; 
                src.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) { isSimulating = true; }

            const layer = document.getElementById('entry-layer');
            layer.style.opacity = 0;
            setTimeout(() => {
                layer.style.display = 'none';
                document.getElementById('signature').classList.add('visible');
                document.getElementById('mode-selector').classList.add('visible');
                document.getElementById('top-bar').classList.add('visible');
                resetIdleTimer();
            }, 1000);
            isRunning = true;
        }

        // --- 2. 场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012); 
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 80);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, alpha: false, powerPreference: "high-performance", preserveDrawingBuffer: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const fadeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.15 });
        const fadePlane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), fadeMaterial);
        fadePlane.position.z = -1; 
        const fadeScene = new THREE.Scene();
        fadeScene.add(fadePlane);

        const pCount = CONFIG.gridX * CONFIG.gridZ;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(pCount * 3);
        const colors = new Float32Array(pCount * 3);
        const sizes = new Float32Array(pCount);
        const baseCoords = new Float32Array(pCount * 2);

        let i = 0;
        const offsetX = (CONFIG.gridX * CONFIG.spacing) / 2;
        const offsetZ = (CONFIG.gridZ * CONFIG.spacing) / 2;

        for(let z=0; z<CONFIG.gridZ; z++) {
            for(let x=0; x<CONFIG.gridX; x++) {
                const px = x * CONFIG.spacing - offsetX;
                const pz = z * CONFIG.spacing - offsetZ - 20;
                positions[i*3] = px; positions[i*3+1] = 0; positions[i*3+2] = pz;
                baseCoords[i*2] = px; baseCoords[i*2+1] = pz;
                currentY[i] = 0;
                colors[i*3]=0; colors[i*3+1]=0; colors[i*3+2]=0;
                sizes[i] = 1.0;
                i++;
            }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // 材质：烟雾柔光
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=128;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(64,64,0,64,64,64);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.2, 'rgba(255,255,255,0.4)'); 
        g.addColorStop(0.6, 'rgba(255,255,255,0.05)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
        const tex = new THREE.Texture(canvas); tex.needsUpdate=true;

        const material = new THREE.PointsMaterial({
            size: 3.5, map: tex, vertexColors: true, 
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.65
        });
        const mesh = new THREE.Points(geometry, material);
        scene.add(mesh);

        function animate() {
            requestAnimationFrame(animate);
            if(isPaused) return;
            time += 0.008;

            // 动态更新拖尾背景色
            fadeMaterial.color.copy(CONFIG.colorDeep);
            renderer.render(fadeScene, camera);

            let bass = 0, mid = 0, high = 0;
            let currentVolume = 0;

            if (wallpaperAudioData) {
                let bSum=0, mSum=0, hSum=0;
                for(let k=0; k<4; k++) bSum += wallpaperAudioData[k];
                for(let k=10; k<25; k++) mSum += wallpaperAudioData[k];
                for(let k=40; k<64; k++) hSum += wallpaperAudioData[k];
                bass = (bSum/4); mid = (mSum/15); high = (hSum/24);
                currentVolume = bass + mid + high;
            } else if (isRunning && !isSimulating && analyser) {
                analyser.getByteFrequencyData(dataArray);
                for(let k=0; k<15; k++) bass += dataArray[k]; bass /= 3825; 
                for(let k=20; k<120; k++) mid += dataArray[k]; mid /= 25500;
                for(let k=200; k<500; k++) high += dataArray[k]; high /= 76500;
                currentVolume = bass + mid + high;
            } else {
                bass = (Math.sin(time*2)+1)*0.2; mid = (Math.cos(time*1.5)+1)*0.15; high = (Math.sin(time*4)+1)*0.1;
                currentVolume = 0.5;
            }

            // Auto-Gain
            if (!isSimulating && isRunning) {
                volumeHistory.push(currentVolume);
                if (volumeHistory.length > 60) volumeHistory.shift();
                let avgVol = volumeHistory.reduce((a, b) => a + b, 0) / volumeHistory.length;
                let targetGain = 0.3 / (avgVol + 0.01);
                targetGain = Math.min(Math.max(targetGain, 1.0), 5.0);
                autoGain += (targetGain - autoGain) * 0.05;
            } else { autoGain = 1.0; }

            bass *= autoGain * 1.5; mid *= autoGain * 1.3; high *= autoGain * 1.8;

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            const siz = geometry.attributes.size.array;
            const tempColor = new THREE.Color();

            let targetCamY = 15;
            let targetCamZOffset = 0;
            curMouseX += (mouseX - curMouseX) * 0.05;
            curMouseY += (mouseY - curMouseY) * 0.05;

            for(let i=0; i<pCount; i++) {
                const ix = i*3;
                const bx = baseCoords[i*2]; const bz = baseCoords[i*2+1];
                let targetY = 0; let targetX = bx; let targetZ = bz;

                if (currentMode === 'TIDES') {
                    targetCamY = 15;
                    const wave = Math.sin(bx * 0.05 + time) * Math.cos(bz * 0.05 + time * 0.5) * 3;
                    const xNorm = (bx + offsetX) / (CONFIG.gridX * CONFIG.spacing);
                    const bassFactor = Math.max(0, 1 - xNorm * 1.5);
                    const highFactor = Math.max(0, (xNorm - 0.3) * 1.5);
                    const audioForce = (bass * bassFactor * 35) + (high * highFactor * 30);
                    targetY = wave + Math.sin(bz * 0.2 - time * 3) * audioForce;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.2; 
                    pos[ix] += (targetX - pos[ix]) * 0.1; pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'HORIZON') {
                    targetCamY = 8;
                    const distX = Math.abs(bx);
                    const tunnel = Math.pow(distX / 30, 2.5) * 1.5; 
                    const sway = Math.sin(bx * 0.05 + time * 3); 
                    targetY = tunnel + sway * (bass * 25 + mid * 20);
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.2;
                    pos[ix] += (targetX - pos[ix]) * 0.1; pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'RIPPLE') {
                    targetCamY = 40; targetCamZOffset = 20;
                    const dist = Math.sqrt(bx*bx + bz*bz);
                    const ripple = Math.sin(dist * 0.15 - time * 3);
                    const decay = Math.max(0, 1 - dist / 70);
                    targetY = ripple * decay * (3 + bass * 35 + mid * 15);
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.2;
                    pos[ix] += (targetX - pos[ix]) * 0.1; pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'WARP') {
                    targetCamY = 0; 
                    const angle = (bx / offsetX) * Math.PI; const radius = 35 + bass * 25; 
                    const flowZ = (bz + time * 120) % 100 - 50; 
                    targetX = Math.cos(angle) * radius; targetY = Math.sin(angle) * radius; targetZ = flowZ; 
                    if (high > 0.1) {
                        const spike = Math.random() * high * 6;
                        targetX += Math.cos(angle) * spike; targetY += Math.sin(angle) * spike;
                    }
                    pos[ix] += (targetX - pos[ix]) * 0.15;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.15;
                    if (Math.abs(pos[ix+2] - targetZ) > 50) pos[ix+2] = targetZ;
                    else pos[ix+2] += (targetZ - pos[ix+2]) * 0.2;
                }

                let intensity = 0;
                if (currentMode === 'WARP') intensity = 1 - (Math.abs(pos[ix+2]) / 60);
                else if (currentMode === 'RIPPLE') intensity = (pos[ix+1] + 5) / 25;
                else intensity = (pos[ix+1] + 10) / 30;
                
                intensity = Math.max(0, Math.min(1, intensity));
                intensity = Math.pow(intensity, 2.2);

                tempColor.copy(CONFIG.colorDeep);
                tempColor.lerp(CONFIG.colorPeak, intensity);

                if(intensity > 0.6) tempColor.offsetHSL(0.55, 0, 0.1); 

                if(high > 0.2 && intensity > 0.4) {
                    tempColor.r += high; tempColor.g += high; tempColor.b += high;
                }

                col[ix] = tempColor.r; col[ix+1] = tempColor.g; col[ix+2] = tempColor.b;
                siz[i] = 2.0 + intensity * 15.0; 
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;

            const pX = curMouseX * 5; const pY = -curMouseY * 5;
            camera.position.x += (pX - camera.position.x) * 0.05;
            camera.position.y += ((targetCamY + pY) - camera.position.y) * 0.05;
            camera.position.z = 80 + targetCamZOffset + Math.sin(time * 0.08) * 8;
            camera.lookAt(0, -2, 0);

            renderer.clearDepth();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
