<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SOLAR CORONA | SUN ZHONGHANG</title>
    <style>
        /* 1. 基础环境 */
        body { 
            margin: 0; overflow: hidden; background: #000000; 
            font-family: 'Helvetica Neue', sans-serif; user-select: none; 
            cursor: default;
        }
        
        /* 隐藏光标逻辑 */
        body.hide-cursor { cursor: none; }

        /* 2. 入口层 */
        #entry-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1.5s cubic-bezier(0.6, 0, 0.2, 1);
        }

        .title-group { text-align: center; margin-bottom: 80px; position: relative; z-index: 2; }
        .main-title {
            color: #fff; font-size: 32px; letter-spacing: 15px; font-weight: 300;
            text-shadow: 0 0 50px rgba(255,255,255,0.6); margin-bottom: 15px;
            text-transform: uppercase;
        }
        .sub-title {
            color: rgba(255,255,255,0.4); font-size: 11px; letter-spacing: 10px; 
            font-family: 'Times New Roman', serif; text-transform: uppercase;
        }

        /* 核心按钮 - 日冕光环 */
        .halo-container {
            position: relative; width: 140px; height: 140px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.5s ease-out;
        }
        .halo-container:hover { transform: scale(1.15); }

        .ring-outer {
            position: absolute; width: 100%; height: 100%; border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0%, transparent 60%, rgba(255,255,255,0.9) 100%);
            animation: spin 3s linear infinite; 
            -webkit-mask: radial-gradient(farthest-side, transparent calc(100% - 2px), #fff calc(100% - 2px));
            mask: radial-gradient(farthest-side, transparent calc(100% - 2px), #fff calc(100% - 2px));
        }
        .ring-inner {
            position: absolute; width: 70%; height: 70%; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.15); border-top: 1px solid rgba(255,255,255,0.7);
            animation: spin-rev 5s linear infinite;
        }
        .halo-core {
            position: absolute; width: 40%; height: 40%; border-radius: 50%;
            background: rgba(255,255,255,0.02); box-shadow: 0 0 30px rgba(255,255,255,0.05);
            transition: 0.4s;
        }
        .halo-text {
            position: relative; color: rgba(255,255,255,0.6); font-size: 11px; letter-spacing: 4px;
            z-index: 10; transition: 0.3s; font-weight: 300;
        }

        .halo-container:hover .ring-outer { animation-duration: 1s; opacity: 1; box-shadow: 0 0 50px rgba(255,255,255,0.2); }
        .halo-container:hover .ring-inner { border-color: rgba(255,255,255,0.9); animation-duration: 2s; }
        .halo-container:hover .halo-core { background: #fff; box-shadow: 0 0 80px #fff; }
        .halo-container:hover .halo-text { color: #000; font-weight: 700; letter-spacing: 1px; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes spin-rev { 0% { transform: rotate(360deg); } 100% { transform: rotate(0deg); } }

        /* 3. 底部专属署名 */
        #signature {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.3); font-size: 11px; letter-spacing: 8px;
            pointer-events: none; opacity: 0; transition: opacity 2s; font-weight: 300;
            text-shadow: 0 0 15px rgba(0,0,0,0.8); z-index: 10; font-family: 'Times New Roman', serif;
        }
        
        /* 4. 模式菜单 */
        #mode-selector {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 50px; z-index: 20;
            opacity: 0; transition: opacity 2s 1s;
        }
        .mode-btn {
            background: transparent; border: none; color: #555;
            font-size: 11px; letter-spacing: 3px; cursor: pointer;
            transition: all 0.3s ease; font-weight: 500; padding: 10px 0;
            text-transform: uppercase; position: relative; font-family: sans-serif;
        }
        .mode-btn::after {
            content: ''; position: absolute; bottom: 0px; left: 50%; width: 0%; height: 1px;
            background: #fff; transition: width 0.3s; transform: translateX(-50%);
            opacity: 0.8; box-shadow: 0 0 10px #fff;
        }
        .mode-btn:hover { color: #aaa; }
        .mode-btn.active { color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.4); }
        .mode-btn.active::after { width: 100%; }

        /* 5. 全屏按钮 */
        #btn-fullscreen {
            position: absolute; top: 30px; right: 30px; 
            z-index: 3000;
            background: transparent; border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.4); width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.3s; border-radius: 50%;
            font-size: 16px;
        }
        #btn-fullscreen:hover {
            color: #fff; border-color: rgba(255,255,255,0.5); box-shadow: 0 0 30px rgba(255,255,255,0.1);
        }

        .visible { opacity: 1 !important; pointer-events: auto !important; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <button id="btn-fullscreen" onclick="toggleFullscreen()">⛶</button>

    <div id="entry-layer">
        <div class="title-group">
            <div class="main-title">Solar Corona</div>
            <div class="sub-title">Sun Zhonghang · Exclusive</div>
        </div>
        
        <div class="halo-container" onclick="startSequence()">
            <div class="ring-outer"></div>
            <div class="ring-inner"></div>
            <div class="halo-core"></div>
            <div class="halo-text">ENTER</div>
        </div>
    </div>

    <div id="mode-selector">
        <button class="mode-btn active" onclick="setMode('TIDES')">TIDES</button>
        <button class="mode-btn" onclick="setMode('HORIZON')">HORIZON</button>
        <button class="mode-btn" onclick="setMode('GATEWAY')">GATEWAY</button>
        <button class="mode-btn" onclick="setMode('WARP')">WARP</button>
    </div>

    <div id="signature">SUN ZHONGHANG</div>

    <script>
        // --- 0. 桌面级高配参数 ---
        const CONFIG = {
            gridX: 300, gridZ: 150, spacing: 1.1, // 45,000个粒子
            colorDeep: new THREE.Color("#000000"), 
            colorPeak: new THREE.Color("#ffffff")
        };

        // --- 1. 状态 ---
        let audioCtx, analyser, dataArray;
        let isSimulating = false, isRunning = false, isPaused = false;
        let time = 0;
        let currentMode = 'TIDES'; 
        
        const currentY = new Float32Array(CONFIG.gridX * CONFIG.gridZ); 

        // 键盘监听
        document.addEventListener('keydown', (e) => {
            if (!isRunning) return;
            switch(e.key) {
                case '1': setMode('TIDES'); break;
                case '2': setMode('HORIZON'); break;
                case '3': setMode('GATEWAY'); break;
                case '4': setMode('WARP'); break;
                case ' ': isPaused = !isPaused; break;
                case 'f': toggleFullscreen(); break; 
            }
        });

        // 鼠标监听 (仅用于隐藏光标，不再控制运镜)
        let idleTimer;
        document.addEventListener('mousemove', (e) => {
            document.body.classList.remove('hide-cursor');
            clearTimeout(idleTimer);
            if(isRunning) {
                idleTimer = setTimeout(() => document.body.classList.add('hide-cursor'), 2500);
            }
        });

        window.setMode = (mode) => {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText === mode) btn.classList.add('active');
            });
        };

        window.toggleFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {});
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        };

        async function startSequence() {
            // UI 锁定
            document.querySelector('.halo-container').style.transform = 'scale(0.9)';
            document.querySelector('.halo-container').style.opacity = '0';
            document.querySelector('.halo-container').style.pointerEvents = 'none';
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const src = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; 
                analyser.smoothingTimeConstant = 0.7; // 保持高灵敏度
                src.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) { isSimulating = true; }

            const layer = document.getElementById('entry-layer');
            layer.style.opacity = 0;
            setTimeout(() => {
                layer.style.display = 'none';
                document.getElementById('signature').classList.add('visible');
                document.getElementById('mode-selector').classList.add('visible');
                idleTimer = setTimeout(() => document.body.classList.add('hide-cursor'), 2500);
            }, 1000);
            isRunning = true;
        }

        // --- 2. 场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012); 
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.set(0, 15, 80);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // --- 3. 粒子 ---
        const pCount = CONFIG.gridX * CONFIG.gridZ;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(pCount * 3);
        const colors = new Float32Array(pCount * 3);
        const sizes = new Float32Array(pCount);
        const baseCoords = new Float32Array(pCount * 2);

        let i = 0;
        const offsetX = (CONFIG.gridX * CONFIG.spacing) / 2;
        const offsetZ = (CONFIG.gridZ * CONFIG.spacing) / 2;

        for(let z=0; z<CONFIG.gridZ; z++) {
            for(let x=0; x<CONFIG.gridX; x++) {
                const px = x * CONFIG.spacing - offsetX;
                const pz = z * CONFIG.spacing - offsetZ - 20;
                positions[i*3] = px; positions[i*3+1] = 0; positions[i*3+2] = pz;
                baseCoords[i*2] = px; baseCoords[i*2+1] = pz;
                currentY[i] = 0;
                colors[i*3]=0; colors[i*3+1]=0; colors[i*3+2]=0;
                sizes[i] = 1.0;
                i++;
            }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // 材质
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=128;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(64,64,0,64,64,64);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.3, 'rgba(255,255,255,0.8)');
        g.addColorStop(0.5, 'rgba(255,255,255,0.15)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
        const tex = new THREE.Texture(canvas); tex.needsUpdate=true;

        const material = new THREE.PointsMaterial({
            size: 1.1, map: tex, vertexColors: true, 
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0
        });
        const mesh = new THREE.Points(geometry, material);
        scene.add(mesh);

        // --- 4. 循环 ---
        function animate() {
            requestAnimationFrame(animate);
            if(isPaused) return;
            time += 0.008;

            let bass = 0, mid = 0, high = 0;
            if(isRunning && !isSimulating && analyser) {
                analyser.getByteFrequencyData(dataArray);
                for(let k=0; k<15; k++) bass += dataArray[k]; bass /= 3825; 
                for(let k=20; k<120; k++) mid += dataArray[k]; mid /= 25500;
                for(let k=200; k<500; k++) high += dataArray[k]; high /= 76500;
                bass *= 1.5; mid *= 1.4; high *= 2.0;
            } else {
                bass = (Math.sin(time*2)+1)*0.2; mid = (Math.cos(time*1.5)+1)*0.15; high = (Math.sin(time*4)+1)*0.1;
            }

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            const siz = geometry.attributes.size.array;
            const tempColor = new THREE.Color();

            let targetCamY = 15;
            let targetCamZOffset = 0;

            for(let i=0; i<pCount; i++) {
                const ix = i*3;
                const bx = baseCoords[i*2]; 
                const bz = baseCoords[i*2+1];
                let targetY = 0;
                let targetX = bx;
                let targetZ = bz;

                // --- 动效逻辑 ---
                if (currentMode === 'TIDES') {
                    targetCamY = 15;
                    const wave = Math.sin(bx * 0.05 + time) * Math.cos(bz * 0.05 + time * 0.5) * 3;
                    const xNorm = (bx + offsetX) / (CONFIG.gridX * CONFIG.spacing);
                    const bassFactor = Math.max(0, 1 - xNorm * 1.5);
                    const highFactor = Math.max(0, (xNorm - 0.3) * 1.5);
                    const audioForce = (bass * bassFactor * 35) + (high * highFactor * 30);
                    targetY = wave + Math.sin(bz * 0.2 - time * 3) * audioForce;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.25; 
                    pos[ix] += (targetX - pos[ix]) * 0.1;
                    pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'HORIZON') {
                    targetCamY = 8;
                    const distX = Math.abs(bx);
                    const tunnel = Math.pow(distX / 30, 2.5) * 1.5; 
                    const flow = Math.sin(bz * 0.1 + time * 6);
                    targetY = tunnel + flow * (bass * 22 + mid * 18);
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.25;
                    pos[ix] += (targetX - pos[ix]) * 0.1;
                    pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'GATEWAY') {
                    targetCamY = 10;
                    const gateStructure = Math.cos(bx * 0.15) * Math.sin(bz * 0.05 + time);
                    targetY = gateStructure * (10 + bass * 55);
                    if (Math.abs(bx) < 20) targetY += (Math.random()-0.5) * high * 35;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.25;
                    pos[ix] += (targetX - pos[ix]) * 0.1;
                    pos[ix+2] += (targetZ - pos[ix+2]) * 0.1;

                } else if (currentMode === 'WARP') {
                    targetCamY = 0; 
                    const angle = (bx / offsetX) * Math.PI; 
                    const radius = 30 + bass * 25; 
                    const flowZ = (bz + time * 120) % 100 - 50; 
                    targetX = Math.cos(angle) * radius;
                    targetY = Math.sin(angle) * radius;
                    targetZ = flowZ; 
                    if (high > 0.1) {
                        const spike = Math.random() * high * 6;
                        targetX += Math.cos(angle) * spike;
                        targetY += Math.sin(angle) * spike;
                    }
                    pos[ix] += (targetX - pos[ix]) * 0.15;
                    pos[ix+1] += (targetY - pos[ix+1]) * 0.15;
                    if (Math.abs(pos[ix+2] - targetZ) > 50) pos[ix+2] = targetZ;
                    else pos[ix+2] += (targetZ - pos[ix+2]) * 0.2;
                }

                // --- 着色 (引入动态金属光泽) ---
                let intensity = 0;
                if (currentMode === 'WARP') {
                    intensity = 1 - (Math.abs(pos[ix+2]) / 60);
                    intensity += mid * 0.5;
                } else {
                    intensity = (pos[ix+1] + 10) / 30;
                }
                
                intensity = Math.max(0, Math.min(1, intensity));
                intensity = Math.pow(intensity, 2.2);

                tempColor.copy(CONFIG.colorDeep);
                tempColor.lerp(CONFIG.colorPeak, intensity);

                if(intensity > 0.6) {
                    tempColor.offsetHSL(0.55, 0, 0.1); 
                }

                if(high > 0.2 && intensity > 0.4) {
                    tempColor.r += high; tempColor.g += high; tempColor.b += high;
                }

                col[ix] = tempColor.r; col[ix+1] = tempColor.g; col[ix+2] = tempColor.b;
                siz[i] = 0.5 + intensity * 4.5;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;

            // 运镜平滑 (无视差)
            camera.position.y += (targetCamY - camera.position.y) * 0.05;
            camera.position.z = 80 + targetCamZOffset + Math.sin(time * 0.08) * 8;
            camera.lookAt(0, -2, 0);

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>